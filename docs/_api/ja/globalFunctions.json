{
    "render": {
        "comment": {
            "parameters": {
                "result": {
                    "comment": {
                        "shortText": [
                            "`html`や`svg`のようなテンプレートタグを評価することによって作成されたTemplateResultです。"
                        ]
                    }
                },
                "container": {
                    "comment": {
                        "shortText": [
                            "レンダリングするDOMの親。以前に同じ結果の型がレンダリングされた場合、内容全体が置換されるか、効率的に更新されます。"
                        ]
                    }
                },
                "options": {
                    "comment": {
                        "shortText": [
                            "このコンテナに描画されるレンダリングツリー全体のレンダリングオプション。以前レンダリングされたDOMには影響しないため、レンダリングオプションは同じコンテナで変更しないでください。"
                        ]
                    }
                }
            },
            "text": [
                "コンテナを新しい値で更新するには、テンプレートリテラルを再評価し、新しい結果で `render`を呼び出します。"
            ],
            "shortText": "テンプレートをコンテナにレンダリングします。"
        }
    },
    "prepareTemplateStyles": {
        "comment": {
            "text": [
                "`<style>`要素は初期レンダリングの時のみ置くことができます。",
                "`<style>`要素をテンプレートに含めて動的にレンダリングした場合（最初のスコープレンダリング時）、それらはスコープに入らず、`<style>`はテンプレートに残ったままで、出力だけされます。"
            ],
            "shortText": [
                "指定されたスコープ名に対して、ShadyCSSスタイルスコープは確実に実行されます。これは、スコープ名ごとに1回だけ実行されるため、フラグメントとテンプレートは変更されません。",
                "(1) レンダリングされたフラグメントからスタイルを抽出し、ShadyCSSに渡してスコープを設定し、ドキュメントに追加します",
                "(2) このスコープ名のすべてのlit-htmlテンプレートからスタイル要素を削除します"
            ]
        }
    },
    "removeStylesFromLitTemplates": {
        "comment": {
            "shortText": "指定されたscopeNameのTemplatesからすべてのスタイル要素を削除します。"
        }
    },
    "shadyTemplateFactory": {
        "comment": {
            "shortText": "ShadyCSSを使用してテンプレートDOMをスコープするテンプレートファクトリ。"
        }
    },
    "insertNodeIntoTemplate": {
        "comment": {
            "shortText": [
                "指定されたノードをテンプレートに挿入します。オプションで指定したrefNodeの前に挿入します。 テンプレートにノードを挿入するだけでなく、テンプレート・パーツのインデックスは、変更されたテンプレートDOMに一致するように更新されます。"
            ]
        }
    },
    "removeNodesFromTemplate": {
        "comment": {
            "text": [
                "テンプレートは削除状態に追従し、必要に応じて部分インデックスが調整されます。",
                "div",
                "  div#1 (削除) <-- 削除開始 (div#1のノードが削除される)",
                "    div",
                "      div#2 (削除)  <-- 続いて削除される (削除しているのはdiv#1ノード)",
                "        div",
                "div <-- 直前の兄弟ノードなので、削除をストップする (div#1によって4ノードが削除された)"
            ],
            "shortText": [
                "テンプレートから安全にノードリストを削除します。テンプレートからノードを削除するだけでなく、テンプレート・パーツのインデックスは、変更されたテンプレートDOMに一致するように更新されます。"
            ]
        }
    },
    "svg": {
        "comment": {
            "shortText": [
                "テンプレートリテラルをSVGテンプレートとして解釈し、コンテナへ効率的にレンダリングおよび更新します。"
            ]
        }
    },
    "html": {
        "comment": {
            "shortText": [
                "テンプレートリテラルをHTMLテンプレートとして解釈し、コンテナへ効率的にレンダリングおよび更新します。"
            ]
        }
    },
    "templateFactory": {
        "comment": {
            "shortText": [
                "テンプレートをキャッシュするデフォルトのTemplateFactoryは、result.typeとresult.stringsをキーとします。"
            ]
        }
    },
    "removeNodes": {
        "comment": {
            "shortText": [
                "`startNode`(包含)から`endNode`(排他)まで、 `container`からノードを削除します。"
            ]
        }
    },
    "reparentNodes": {
        "comment": {
            "shortText": [
                "親要素を切り替える為に、`beforeNode`の前へ`startNode`(包含)から`endNode`(排他)までを、別のコンテナ(同じコンテナでも)に挿入します。`beforeNode`がnullの場合、ノードをコンテナに追加します。"
            ]
        }
    },
    "directive": {
        "comment": {
            "parameters": {
                "f": {
                    "comment": {
                        "shortText": [
                            "ディレクティブのファクトリ関数。`(part：Part) => void`を返す関数でなければなりません。返された関数は、パーツオブジェクトとともに呼び出されます。"
                        ]
                    }
                }
            },
            "shortText": [
                "ディレクティブとしてlit-htmlがテンプレートを描画するのに(値ではなく)関数として呼び出せるように定義します"
            ]
        }
    },
    "lit-html": {
        "comment": {
            "text": [
                "コンテナを新しい値で更新するには、テンプレートリテラルを再評価し、新しい結果で `render`を呼び出します。"
            ],
            "shortText": "テンプレートをコンテナにレンダリングします。"
        }
    },
    "shady-render": {
        "comment": {
            "shortText": "テンプレートレンダリングにshady DOM/shady CSSをサポートを追加するモジュール。詳細についてはrenderメソッドを参照してください。"
        }
    },
    "TemplateFactory": {
        "comment": {
            "text": [
              "TemplateResultからテンプレートを作成するファクトリ。",
              "",
              "これは、クラスを要素に追加してスタイルを削除しなければならないShadyCSSのように、テンプレートを使用する前にテンプレートの変更を必要とするレンダリングのテンプレート作成プロセスへのフックです。",
              "",
              "テンプレートはできるだけ積極的にキャッシュする必要があります。そのため、同じ式から生成された多くのTemplateResultsが最初にテンプレートを作成する作業を行うだけです。",
              "",
              "テンプレートは、通常、TemplateResult.stringsとTemplateResult.typeによってキャッシュされますが、この関数がテンプレートを変更する場合は、他のキーによってキャッシュされることがあります。",
              "",
              "現在、TemplateFactoriesは式を追加、削除、並べ替えてはいけないことに注意してください。これは、テンプレートインスタンス内の正しい場所に値が補間されるようにrender()の変更を記述する方法がないためです。"
            ]
        }
    },
    "templateCache": {
        "comment": {
            "text": [
              "JSテンプレートタグの最初の引数は、同じリテラルのタグを複数回呼び出すときに同一性を保持するため、リテラルごとに行われた作業をマップにキャッシュできます。",
              "",
              "Safariには現在バグがあり、時々この動作が壊れるため、テンプレートを2つのレベルでキャッシュする必要があります。最初にTemplateStringsArrayをキャッシュし、失敗した場合はstrings配列を結合して構築したキーをキャッシュします。"
            ]
        }
    },
    "TemplatePart": {
        "comment": {
            "text": [
              "HTMLテンプレート内の動的式のプレースホルダ。",
              "",
              "属性パーツとノードパーツという2つの組み込みパーツタイプがあります。 ノードパーツは常に単一の動的式を表しますが、属性パーツは属性の型によっていくつか変ります。",
              "",
              "テンプレートのパーツは変更可能であるため、パーツを置き換えたり、変更したりすることができます（異なるテンプレートのセマンティクスを実装する可能性があります）。 仕様としてはパーツの置換のみ可能で、削除、追加、並べ替えはできず、パーツは常に `update()`メソッドで正しい数の値を使用しなければなりません。",
              "",
              "TODO(justinfagnani): この要件は少し壊れやすいです。 TemplateInstanceはPart.update()を使うことによってより値を注意して扱うことができます。"
            ]
        }
    },
    "boundAttributeSuffix": {
        "comment": {
            "shortText": "すべてのバインドされた属性名に追加される接尾辞"
        }
    },
    "isCEPolyfill": {
        "comment": {
            "shortText": "カスタム要素polyfillが使用されている場合はtrue"
        }
    },
    "lastAttributeNameRegex": {
        "comment": {
            "text": [
              "この正規表現は、属性位置式の前にある属性名を抽出します。これは、式の属性値の位置にあると仮定して、式の直前にある文字列リテラルに対して属性に許可されている構文を照合します。",
              "",
              "HTML仕様の属性を参照してください:",
              "https://www.w3.org/TR/html5/syntax.html#attributes-0",
              "",
              "\"\\0-\\x1F\\x7F-\\x9F\" Unicode制御文字",
              "",
              "\"\\x09\\x0a\\x0c\\x0d\" HTML空白文字:",
              "https://www.w3.org/TR/html5/infrastructure.html#space-character",
              "",
              "したがって、属性は次のとおりです:",
              " * name: 制御文字以外の任意の文字、空白文字, ('), (\"), \">\", \"=\", or \"/\"",
              " * 0個以上のスペース文字が続く",
              " * それに続く \"=\"",
              " * 0個以上のスペース文字が続く",
              " * 下記に続く:",
              "   * スペース以外の文字, ('), (\"), \"<\", \">\", \"=\", (`), もしくは",
              "   * (\") の次に (\") でないもの, もしくは",
              "   * (') の次に (') でないもの"
            ]
        }
    },
    "marker": {
        "comment": {
            "shortText": "テンプレート内の可能なテキストとの衝突を避けるために、固有のキーが埋め込まれた式マーカ"
        }
    },
    "noChange": {
        "comment": {
            "shortText": "ディレクティブによって値が処理されたことを通知し、DOMに書き込まれてはならないことを示す目印の値"
        }
    },
    "nodeMarker": {
        "comment": {
            "shortText": "テキストコンテンツ、マルチバインディング属性、属性に使用するマークアップに近い式マーカ"
        }
    }
}
